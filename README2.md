<a name="_hznop31dhkm7"></a>Практична робота № 2

-----
## <a name="_o3arbnwg9btw"></a>**Завдання 1:** 
Напишіть програму для визначення моменту, коли time\_t

закінчиться. Дослідіть, які зміни відбуваються в залежності від 32- та

64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

-----
## <a name="_d3t8k87t1vn3"></a>**Виконанне завдання 1:** 

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.001.png)

Рис 1. Компіляція та виконання програми в 32-bit системі.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.002.png)

Рис 2. Компіляція та виконання програми в 64-bit системі.
### <a name="_5bm7rv8k55rr"></a>**Відповідь на питання:** 
Різниця виконання програми в 32 та 64 bit системах. В тому, що 64 є більшою на 4 байта через  що вона працює і зберігає більше даних, аніж 32 bit система, яка працює тільки з 4 байтами. Перевантаження оператора time\_t призводить до скидання даних на перший індекс, тобто на нуль. Це можна наглядно побачити в 32 bit системі, але в 64 bit системі це важче через більший розмір time\_t в системі.

-----
## <a name="_zctd5cw98q7t"></a>**Завдання 2.2:** 
Розгляньте сегменти у виконуваному файлі.

1\. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для

виконуваного файлу, щоб отримати його загальний розмір, і

запустіть size, щоб отримати розміри сегментів всередині нього.

2\. Додайте оголошення глобального масиву із 1000 int,

перекомпілюйте й повторіть вимірювання. Зверніть увагу на

відмінності.

3\. Тепер додайте початкове значення в оголошення масиву

(пам’ятайте, що C не змушує вас вказувати значення для кожного

елемента масиву в ініціалізаторі). Це перемістить масив із сегмента

BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на

різницю.

4\. Тепер додайте оголошення великого масиву в локальну функцію.

Оголосіть другий великий локальний масив з ініціалізатором.

Повторіть вимірювання. Дані розташовуються всередині функцій,

залишаючись у виконуваному файлі? Яка різниця, якщо масив

ініціалізований чи ні?

5\. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви

компілюєте для налагодження? Для максимальної оптимізації?

-----

### <a name="_72jiu6ewar9u"></a>**1.**
![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.003.png)

Рис 3. компіляція файлу hello.c, та вивід розміру виконаного файлу.
### <a name="_j7c5dkq5toc6"></a>**2.**
![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.004.png)

Рис 4. компіляція файлу hello.c, та вивід розміру виконаного файлу, після додавання неініціалізованого масиву.
### <a name="_fibmb1z0604v"></a>**3.**
![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.005.png)

Рис 5. компіляція файлу hello.c, та вивід розміру виконаного файлу, після додавання ініціалізованого масиву.
### <a name="_3qfdbvex8zya"></a>**4.![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.006.png)**
Рис 6. компіляція файлу hello.c, та вивід розміру виконаного файлу, після додавання двох локальних масивів.

### <a name="_3ipdq2y8vo9g"></a>**Відповіді на питання:**
1\. І так і ні. Змінні локальні не статичні не зберігаються, а стають інструкціями. Натомість, статичні змінні зберігаються в комірці “Data”.

2\.Якщо масив створений без ініціалізації то компілятор не виділить під нього пам’ять в комірці”Data”, натомість виділить віртуальну пам’ять.Під ініціалізовані масиви компілятор виділяє пам’ять, аби забезпечити стабільну роботу системи та відсутність витоків пам’яті.

### <a name="_cyc6yahrhvtg"></a>**5.**
Під час процесу оптимізації розмір файлу зменшується, через видалення усіх мета даних про колишні помилки системи. Розміри сегментів теж значно зменшуються через видалення мертвого коду, видалення не потрібних констант, та розгортання циклів.

-----
## <a name="_3f3fl7t4a5bw"></a>**Завдання 2.3:** 
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне

розташування стека у вашій системі:

#include <stdio.h>;

int main() {

`  `int i;

`  `printf(“The stack top is near %p\n”;, &i);

`  `return 0;

}

Знайдіть розташування сегментів даних і тексту, а також купи всередині

сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і

виведіть їхні адреси.

Збільшіть розмір стека, викликавши функцію й оголосивши кілька

великих локальних масивів. Яка зараз адреса вершини стека?

-----

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.007.png)

Рис 7. скомпільований код, розташування мого стеку.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.008.png)

Рис 8. код програми, для знаходження окремих сегментів пам’яті

Зкомпільована програма, розташування сегментів.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.009.png)

Рис 9. скомпільована програма, з даними розташування стеків.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.010.png)

Рис 10. код програми, для збільшення розміру стеку.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.011.png)

Рис 11. скомпільована програма, з даними розташуваннями вершин.

-----
## <a name="_15sjock2zuli"></a>**Завдання 2.4:** 
Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви

можете:

● Автоматично за допомогою утиліти gstack.

● Вручну за допомогою налагоджувача GDB.

Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання

(Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути

pstack). Якщо gstack не працює, використовуйте другий метод – через

GDB, як показано нижче.

Спочатку подивіться на стек за допомогою gstack(1). Нижче наведений

приклад стека bash (аргументом команди є PID процесу):

$ gstack 14654

#0 0x00007f359ec7ee7a in waitpid () from /lib64/libc.so.6

#1 0x000056474b4b41d9 in waitchild.isra ()

#2 0x000056474b4b595d in wait\_for ()

#3 0x000056474b4a5033 in execute\_command\_internal ()

#4 0x000056474b4a5c22 in execute\_command ()

#5 0x000056474b48f252 in reader\_loop ()

#6 0x000056474b48dd32 in main ()

$

Розбір стека:

● Номер кадру стека відображається ліворуч перед символом #.

● Кадр #0 – це найнижчий кадр. Читайте стек знизу вверх (тобто від

`   `main() – кадр #6 – до waitpid() – кадр #0).

● Якщо процес багатопотоковий, gstack покаже стек кожного потоку

`   `окремо.

Аналіз стека в режимі користувача через GDB

Щоб переглянути стек процесу вручну, використовуйте GDB,

приєднавшись до процесу.

Нижче наведена невелика тестова програма на C, що виконує кілька

вкладених викликів функцій. Граф викликів виглядає так:

main() → foo() → bar() → bar\_is\_now\_closed() → pause()

Системний виклик pause() – це приклад блокуючого виклику. Він

переводить викликаючий процес у сплячий режим, очікуючи (або

блокуючи) сигнал. У цьому випадку процес блокується, поки не отримає

будь-який сигнал.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.012.png)

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.013.png)

Тепер відкрийте GDB

У ньому підключіться (attach) до процесу (в наведеному прикладі PID =

\24957) і дослідіть стек за допомогою команди backtrace (bt):

$ gdb --quiet

(gdb) attach 24957

Attaching to process 24957

Reading symbols from &lt;...&gt;/hspl/unit2/stacker...done.

Reading symbols from /lib64/libc.so.6...Reading symbols from

/usr/lib/debug/usr/lib64/libc-2.26.so.debug...done.

done.

Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols

...

(gdb) bt

…

Примітка: В Ubuntu, через питання безпеки, GDB не дозволяє

підключатися до довільного процесу. Це можна обійти, запустивши GDB

від імені користувача root.

Аналіз того ж процесу через gstack

$ gstack 24957

...

gstack — це, по суті, оболонковий скрипт (wrapper shell script), який

неінтерактивно викликає GDB і запускає команду backtrace, яку ви

щойно використали.

Завдання: Ознайомтеся з виводом gstack і порівняйте його з GDB.

-----
![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.014.png)

Рис 12. скомпільована програма, з виконанням GDB.
### <a name="_oy57zx1e0g8k"></a>**Пояснювальна записка:** 
На жаль ні gstack, ні pstack не працюють в мене в компіляторі. Через це я,на жаль, не зміг виконати завдання повноцінно!

-----
## <a name="_tv49rz4xi2a5"></a>**Завдання 2.5:** 
Відомо, що при виклику процедур і поверненні з них процесор

використовує стек.Чи можна в такій схемі обійтися без лічильника команд

(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою

відповідь та наведіть приклади.

-----
### <a name="_3t9y8fnoju1c"></a>**Відповідь на питання:**
Так, це можливо, але неефективно. Якщо ми приберемо IP команди й замість нього будемо використовувати вершину стека. Список команд які нам треба буде виконати збільшиться і це сповільнить роботу системи. Як приклад якщо в програмі нам треба викликати функцію 100 разів то в системі без IP нам треба буде зберігати кожний виклик в стеці - це не ефективно. Натомість в системі з IP команд ми можемо звернутися до команди напряму і не створювати нові виклики функції, а використати вже чинний виклик.

-----
## <a name="_7akcg99g86qd"></a>**Завдання ПО ВАРІАНТАХ**
10\. Аналізуйте поведінку динамічних бібліотек під час завантаження.

-----
![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.015.png)

Рис 13. Аналіз динамічних бібліотек через команду ldd.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.016.png)

Рис 14. Аналіз динамічних бібліотек через LD\_DEBUG.

![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.017.png)![](Aspose.Words.98f418b3-395c-4e9f-a354-06f24ab81efe.018.png)

Рис 15. Аналіз динамічних бібліотек через strace.
